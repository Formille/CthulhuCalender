## 배경

The Arkham Detective Calendar Adventure

이 자료들은 1926년 가상의 도시 아컴을 배경으로 한 1인용 캘린더 게임인 **'365 어드벤처: 크툴루'**에 대해 설명하고 있습니다. 플레이어는 사설 탐정 존 밀러가 되어 1년 동안 매일 한 칸씩 달력을 넘기며 기괴한 사건과 공포스러운 존재들을 마주하게 됩니다. 게임의 핵심 방식은 주사위 굴리기를 통해 전투, 조사, 추적과 같은 다양한 조우를 해결하고 단서를 수집하는 것입니다. 매주 일요일에는 그동안 모은 정보를 바탕으로 더 난이도 높은 특별한 사건을 해결해야 하는 것이 특징입니다. 시간이 흐름에 따라 새로운 규칙과 아이템이 추가되며 캐릭터의 정신력 관리와 점수 합산이 게임의 승패를 결정짓습니다. 전체적으로 크툴루 신화의 신비로운 분위기 속에서 매일 조금씩 서사를 진행하는 독특한 게임 방식을 안내합니다.


---

## 요청사항

기본 규칙상 중요한 내용 정리해줘

---

## 답변


제공해주신 자료를 바탕으로 **'365 어드벤처 - 크툴루(365 Abenteuer - Cthulhu)'**의 기본 규칙 중 핵심 내용을 정리해 드리겠습니다.
1. 게임 진행 방식 (일일 루틴)
• 매일의 행동: 플레이어는 주인공 '존 밀러'가 되어 1년 동안 매일 모험을 진행합니다. 날짜에 맞춰 존을 해당 칸으로 이동시키고, **이번 주(월~토)**에 해당하는 칸 중 하나를 골라 조우(Encounter)를 해결해야 합니다,.
• 자유로운 선택: 반드시 '오늘' 날짜의 조우를 해결할 필요는 없습니다. 이번 주 내에서 아직 해결하지 않은 다른 요일의 칸을 선택해 조사할 수 있습니다,. 단, 이미 완료한 조우나 다음 달에 있는 조우는 선택할 수 없습니다.
2. 주사위 굴림 및 성공 조건
• 주사위 구성: 검은색 숫자 주사위 3개와 초록색 기호 주사위 2개, 총 5개의 주사위를 사용합니다.
• 굴림 규칙: 주사위는 최대 3번까지 굴릴 수 있습니다. 첫 번째나 두 번째 굴림 후 원하는 주사위는 남겨두고 나머지 주사위만 다시 굴릴 수 있습니다.
• 성공 조건: 조우를 해결하려면 다음 두 가지 조건을 동시에 충족해야 합니다.
    1. 숫자 합계: 검은색 주사위 3개의 합이 조우 칸에 적힌 숫자(난이도) 이상이어야 합니다.
    2. 기호 일치: 초록색 주사위 중 적어도 1개가 조우 칸에 표시된 기호(권총, 돋보기, 손전등)와 일치해야 합니다.
3. 일요일의 특별 규칙 (주간 결산)
• 고정된 조우: 일요일 칸은 해당 주 일요일 당일에만 진행할 수 있으며, 다른 요일로 대체할 수 없습니다. 일요일은 한 주간의 조사를 종합하는 중요한 전환점입니다,.
• 난이도 감소: 일요일의 조우는 방패 모양의 숫자로 표시되며 기본 난이도가 높습니다(10~20). 하지만 이번 주에 성공적으로 완료한 조우 1개당 일요일 조우의 난이도가 1씩 감소합니다. 즉, 평일에 조사를 성실히 수행할수록 일요일의 위협을 더 쉽게 해결할 수 있습니다.
4. 광기(Wahnsinn) 시스템
• 광기 증가: 조우 해결 후(성공 여부와 관계없이) 검은색 숫자 주사위 중 하나라도 **'크툴루 기호(문어 머리)'**가 나오면 존의 광기 수치가 올라갑니다. 달력 상단에 있는 광기 칸을 하나 색칠해야 합니다,.
• 초기화: 광기 수치는 매월 초에 0으로 초기화됩니다.
5. 점수 계산 및 월간 진행
• 점수: 매달 마지막에 점수를 계산합니다. 성공한 일요일 조우(특별 조우) 하나당 +5점을 얻지만, 해당 월의 광기 칸이 모두 채워졌다면 -5점의 페널티를 받습니다.
• 게임의 진화: 달력이 넘어갈 때마다 이전 달 뒷면에 있는 새로운 스토리와 규칙이 공개됩니다. 이를 통해 새로운 아이템이나 규칙이 추가되며 게임이 연말까지 계속 변화합니다,.
요약하자면: 평일(월~토)에는 자유롭게 사건을 골라 단서를 모으고(성공 횟수 누적), 이를 통해 난이도를 낮춰 일요일의 보스전(특별 조우)을 해결하는 것이 이 게임의 핵심 전략입니다.



---

## 요청사항

이 캘린더 형식의 게임을 진행하면서 매일의 결과에 따라서 AI가 스토리를 진행해주는 앱을 개발하려고 해. 어떤 초기 정보가 필요할까?

---

## 답변

매일의 게임 결과에 따라 내러티브를 생성해 주는 AI 앱을 개발하신다면, 게임의 규칙과 스토리 진행 방식에 맞춰 AI가 **'현재 상황'**과 **'결과'**를 정확히 인식할 수 있도록 구조화된 프롬프트(입력 정보)가 필요합니다.
제공된 자료를 바탕으로 앱 개발 시 AI에게 제공해야 할 필수 초기 정보와 매일의 입력 변수를 정리해 드립니다.
1. 기본 설정 정보 (System Prompt)
가장 먼저 AI가 자신이 누구이며 어떤 세계관 속에 있는지 알아야 합니다.
• 주인공 페르소나: 1926년 아캄(Arkham)의 사설탐정 '존 밀러(John Miller)'.
• 세계관 분위기: 러브크래프트적 공포(Cthulhu Mythos). 어두운 골목, 불가사의한 공포, 광신도, 고대 존재, 현실과 광기의 경계.
• AI의 역할: 게임 마스터(GM) 겸 내레이터. 플레이어의 주사위 결과에 따라 전투 장면이나 조사 과정을 묘사해야 합니다.
2. 매일 입력해야 할 변수 (Daily Inputs)
플레이어가 앱에 매일 입력해줘야 하는 정보입니다. 이 정보가 있어야 AI가 그날의 에피소드를 작성할 수 있습니다.
A. 오늘의 날짜와 선택한 조우 (Target Encounter)
• 현재 날짜: 예) 1월 2일 금요일.
• 선택한 칸(조우): 규칙상 오늘 날짜가 아니더라도 **'이번 주'**의 다른 칸을 선택할 수 있으므로, 플레이어가 실제로 어떤 칸을 해결하려는지 알아야 합니다.
• 조우 대상의 시각적 정보: 해당 칸의 그림이 무엇인지(예: 총 든 할머니, 검은 고양이, 박쥐, 컬트 신자 등). AI가 적으로 무엇이 등장했는지 묘사하기 위해 필수입니다.
B. 조우 유형 (Action Type) 칸에 그려진 아이콘에 따라 AI가 묘사해야 할 행동 양식이 달라집니다.
• 권총 (Pistol): 전투 상황. 괴물이나 광신도와의 물리적 충돌 묘사.
• 돋보기 (Lupe): 조사 활동. 단서를 찾거나 문서를 해독하는 과정 묘사.
• 손전등 (Flashlight): 수색 및 추격. 어둡고 위험한 장소 탐험 묘사.
C. 주사위 결과 (Result)
• 성공 여부: 숫자 합계 달성 및 기호 일치 여부.
    ◦ 성공 시: 단서를 찾거나 적을 물리친 영웅적인 서사.
    ◦ 실패 시: 도망치거나, 조사가 허탕을 치거나, 부상을 입는 서사.
• 광기(Madness) 발동 여부: 검은 주사위에 **'크툴루 기호'**가 나왔는지 여부.
    ◦ 발동 시: 성공/실패와 별개로 존 밀러가 환청을 듣거나 공포에 질리는 심리적 묘사 추가.
3. 상태 추적 정보 (State Tracking)
AI가 기억하고 있어야 할 장기적인 게임 데이터입니다. 앱 내부 변수로 저장해야 합니다.
• 주간 성공 횟수 (Weekly Success Count):
    ◦ AI는 이번 주(월~토)에 플레이어가 몇 번 성공했는지 카운트해야 합니다.
    ◦ 이유: 일요일(특별 조우)의 난이도가 '성공 횟수'만큼 낮아지기 때문입니다. AI는 일요일 스토리를 진행할 때 "지난주에 모은 단서들 덕분에 결전이 수월해졌다"는 식의 맥락을 반영할 수 있습니다.
• 누적 광기 수치 (Madness Level):
    ◦ 현재 채워진 광기 칸의 개수.
    ◦ 이유: 광기 수치가 높을수록 AI의 묘사가 더 혼란스럽고 절망적으로 변하도록(예: 0일 때는 이성적 추리 -> 가득 찼을 때는 헛것이 보임) 설정할 수 있습니다. 월말 점수 계산(-5점)에도 활용됩니다.
• 월간 진행 상황 (Monthly Progress):
    ◦ 매달 1일이 되면 광기는 0으로 초기화하고, 새로운 달의 테마로 넘어갑니다.
4. 월별 업데이트 정보 (Legacy Updates)
이 게임은 달력이 넘어갈 때마다 새로운 규칙이나 아이템이 추가되는 레거시(Legacy) 요소를 가지고 있습니다.
• 새로운 규칙/아이템: 매달 뒷면에 공개되는 새로운 스토리와 규칙(예: 유물 획득, 새로운 적 등장 등)을 입력받는 필드가 필요합니다. AI는 이를 반영하여 이후 스토리 묘사에 해당 아이템을 사용하는 장면을 넣어야 합니다.
요약: 개발 시 핵심 데이터 구조
앱 개발 시 AI 프롬프트에 들어갈 핵심 구조는 다음과 같습니다.
"지금은 1월 [X]일이고, 플레이어는 [요일] 칸에 있는 **[대상: 예-검은 고양이]**를 상대로 **[유형: 예-손전등/수색]**을 진행했어. 주사위 결과는 **[성공/실패]**였고, 크툴루 기호가 나와서 광기 수치가 [상승함/변화없음] 상태야. 현재까지 이번 주 성공 횟수는 **[N]**번이야. 이 정보를 바탕으로 존 밀러의 짧은 일지(Noir 스타일)를 작성해 줘."


---

## 요청사항

그러면 너가 기본적인 첫 스토리 (제일 무난하게 아컴시티와 사설탐정의 이야기 발단)를 하나 창작해줘

---

## 답변

네, 앱의 도입부에서 사용자가 게임을 시작할 때(1월 1일) AI가 들려줄 수 있는 가장 표준적이고 분위기 있는 오프닝 스토리를 창작해 드리겠습니다.
이 스토리는 자료에 언급된 존 밀러의 캐릭터성, 1926년 아컴의 분위기, 그리고 **게임의 핵심 목표(단서 수집과 생존)**를 반영하여 하드보일드 누아르(Noir) 스타일로 작성했습니다.

--------------------------------------------------------------------------------
📜 프롤로그: 아컴의 그림자 (1926년 1월 1일)
[내레이션 (AI)]
"1926년의 새해가 밝았습니다. 사람들은 희망을 이야기하지만, 매사추세츠의 고대 도시 **아컴(Arkham)**에는 여전히 짙은 안개가 깔려 있습니다.
당신은 날카로운 눈썰미와 그보다 더 날카로운 이성을 가진 사설탐정, **존 밀러(John Miller)**입니다. 낡은 건물들의 그림자 아래 덮인 자갈길 위에서, 당신은 이 도시가 숨기고 있는 '말할 수 없는 공포'와 마주하게 됩니다.
최근 들어 인간이 아닌 듯한 형체들과 어둠의 숭배 집단에 대한 소문이 끊이지 않고 있습니다. 경찰은 이를 헛소문이라 치부하지만, 당신은 알고 있습니다. 현실과 광기의 경계가 무너지고 있다는 것을 말이죠.
당신의 코트 주머니에는 믿음직한 권총이, 손에는 어둠을 밝힐 손전등이 들려 있습니다. 이제 당신은 잊힌 필사본의 단서를 쫓고 금지된 장소를 수색하기 위해 차가운 거리로 나섭니다.
달력의 첫 페이지가 열렸습니다. 이번 주 동안 당신은 도시 곳곳을 뒤져 충분한 **단서(성공 횟수)**를 모아야 합니다. 그래야만 다가올 일요일의 결전에서 살아남을 수 있을 테니까요.
준비되셨습니까, 탐정님? 1월 1일 목요일, 오늘의 조사를 시작할 구역을 선택하십시오."

--------------------------------------------------------------------------------
💡 개발 팁: 이 스토리가 포함하고 있는 AI 초기 설정 요소
이 오프닝은 단순한 텍스트가 아니라, 앞서 논의한 **'필수 초기 정보'**를 플레이어에게 자연스럽게 주입하는 역할을 합니다.
1. 페르소나 확립: "당신은 존 밀러, 사설탐정이다"라고 명시하여 사용자의 몰입을 유도합니다.
2. 세계관 및 긴장감 조성: '1926년 아컴', '광기', '소문' 등의 키워드를 사용해 러브크래프트적 공포 분위기를 설정합니다.
3. 게임 루틴 암시 (튜토리얼 기능):
    ◦ 도구 언급: 권총(전투), 손전등(수색)을 언급하여 주사위 기호의 의미를 상기시킵니다.
    ◦ 목표 제시: "이번 주 동안 단서를 모아 일요일의 결전을 대비한다"는 핵심 규칙(평일 성공 -> 일요일 난이도 하락)을 스토리 내에 녹여냈습니다.
이 스크립트를 앱의 첫 화면에서 텍스트와 함께 음성(TTS)이나 타이핑 효과로 보여준다면, 플레이어가 게임의 규칙과 분위기를 동시에 이해하는 데 큰 도움이 될 것입니다.
이 앱의 스토리는 존 밀러의 일기장을 우리가 엿보는 느낌으로 작성되었으면 좋겠어. 25년 12월 31일의 일기장을 시작으로 게임이 시작될 수 있게 해줘

이 앱의 오프닝을 존 밀러의 비밀스러운 일기장을 훔쳐보는 콘셉트로 설정하는 것은 매우 훌륭한 아이디어입니다. 플레이어가 게임의 규칙을 딱딱하게 배우는 대신, 존의 내면과 동기화되어 자연스럽게 1월 1일의 첫 미션으로 넘어가게 할 수 있습니다.
요청하신 대로, 게임 시작 전날 밤인 1925년 12월 31일의 일기장 내용을 작성해 드립니다. 이 내용은 앱의 첫 화면에서 낡은 종이 질감 위에 타자기 폰트로 서서히 나타나게 연출하면 좋습니다.

--------------------------------------------------------------------------------
📓 존 밀러의 일기: 서막
날짜: 1925년 12월 31일 장소: 매사추세츠주 아캄(Arkham), 탐정 사무소
거리에서는 폭죽 소리가 들려온다. 사람들은 다가올 1926년이 희망으로 가득 찰 것이라 떠들며 축배를 들고 있다. 어리석은 자들. 그들은 아캄의 짙은 안개 속에 무엇이 도사리고 있는지 전혀 모른다.
나는 창밖으로 비치는 낡은 건물들의 그림자를 내려다본다. 최근 내 사무실을 찾아온 의뢰인들의 눈빛에는 공통된 공포가 서려 있었다. 인간이 아닌 듯한 괴물들, 지하에서 들려오는 기이한 주문 소리, 그리고 사라지는 사람들... 경찰은 집단 히스테리라며 무시했지만, 내 직감은 다르게 말하고 있다.
이 도시의 현실과 광기의 경계가 무너지고 있다. '위대한 옛것들'을 숭배하는 광신도들이 어둠 속에서 움직이기 시작했다.
나는 책상 위에 놓인 장비들을 점검했다. 어둠을 밝혀줄 손전등, 그리고 최악의 상황에서 나를 지켜줄 권총 한 자루,. 이것들이 내년 한 해 동안 나의 유일한 벗이 될 것이다.
내일, 1월 1일이 밝는 대로 나는 거리로 나갈 것이다. 매일 아캄의 골목을 뒤지고, 금지된 장소를 수색하여 놈들의 흔적을 찾아내야 한다. 쉽지 않은 싸움이 될 것이다. 때로는 도망쳐야 할 것이고, 때로는 내 이성이 버티지 못하고 광기에 잠식될지도 모른다.
하지만 누군가는 해야만 한다. 놈들이 이 세상을 완전히 삼키기 전에 진실을 밝혀내야 한다. 이 일기장이 나의 유서가 되지 않기를 바라며.
이제, 긴 밤이 지나고 날이 밝으면... 사냥을 시작한다.

--------------------------------------------------------------------------------
💡 개발자 노트: 이 일기장이 포함한 게임 정보
이 스크립트는 단순한 소설이 아니라, 플레이어에게 앱 사용법(게임 규칙)을 은유적으로 전달하고 있습니다.
1. "손전등과 권총": 게임에서 사용하는 주사위 기호(돋보기/손전등/권총)가 앞으로의 플레이에 핵심 도구임을 암시합니다.
2. "매일 아캄의 골목을 뒤지고": 게임이 1년 365일 매일 진행되는 데일리 루틴 형식임을 알려줍니다.
3. "이성이 버티지 못하고 광기에 잠식될지도": 주사위 굴림 실패나 특정 조건에서 발생하는 '광기(Wahnsinn)' 시스템에 대한 예고입니다.
4. "내일, 1월 1일이 밝는 대로": 플레이어가 '다음' 버튼을 눌러 실제 게임(1월 1일 페이지)으로 진입하도록 유도하는 자연스러운 트리거입니다.
이 프롤로그가 끝나면 화면이 암전되었다가, **"1926년 1월 1일 목요일"**이라는 자막과 함께 실제 달력 화면(게임 인터페이스)이 뜨도록 연결하면 완벽한 도입부가 될 것입니다.

---

## 요청사항

다음 이야기를 진행하려면 어떤 요소들이 필요한지 pydantic 스타일로 알려줘

---

## 답변

게임의 규칙과 내러티브 생성에 필요한 데이터 구조를 Pydantic 모델로 정리해 드립니다. 이 구조는 AI가 "존 밀러의 현재 상태", "플레이어의 행동", "주사위 결과"를 정확히 이해하고 스토리를 이어가는 데 필수적입니다.

🐍 Pydantic 모델 설계 (Python Code)

```py
from enum import Enum
from pydantic import BaseModel, Field, field_validator
from typing import List, Optional
from datetime import date

# 1. 조우 유형 (주사위 기호) 정의 [1]
class EncounterType(str, Enum):
    COMBAT = "권총 (전투)"        # Pistol
    INVESTIGATION = "돋보기 (조사)" # Lupe
    SEARCH = "손전등 (수색)"      # Taschenlampe

# 2. 게임의 현재 상태 (Context)
class GameState(BaseModel):
    current_date: date = Field(..., description="현재 게임 날짜 (예: 1926-01-02)")
    madness_level: int = Field(0, ge=0, description="현재 누적된 광기 수치 (월초 0으로 초기화) [2]")
    weekly_success_count: int = Field(0, ge=0, description="이번 주(월~토) 성공 횟수 (일요일 난이도 감소용) [3]")
    active_legacy_rules: List[str] = Field(default=[], description="월별 업데이트로 추가된 새로운 규칙이나 아이템 [4]")

# 3. 플레이어가 선택한 조우 대상 (Input)
class TargetEncounter(BaseModel):
    target_date: date = Field(..., description="선택한 칸의 날짜 (반드시 오늘일 필요는 없음) [5]")
    visual_description: str = Field(..., description="칸에 그려진 그림 묘사 (예: 총을 든 노파, 검은 고양이) [6]")
    required_symbol: EncounterType = Field(..., description="필요한 주사위 기호 [1]")
    base_difficulty: int = Field(..., ge=5, le=20, description="칸에 적힌 기본 난이도 숫자 [1]")
    is_sunday_boss: bool = Field(False, description="일요일 특별 조우 여부 [3]")

    @property
    def narrative_context(self) -> str:
        """AI에게 전달할 상황 묘사 힌트"""
        if self.required_symbol == EncounterType.COMBAT:
            return f"존 밀러는 {self.visual_description}와(과) 물리적으로 충돌합니다."
        elif self.required_symbol == EncounterType.INVESTIGATION:
            return f"존 밀러는 {self.visual_description}에 대해 면밀히 조사합니다."
        return f"존 밀러는 {self.visual_description}이(가) 있는 어두운 곳을 수색합니다."

# 4. 주사위 굴림 결과 (Result)
class DiceResult(BaseModel):
    black_dice_sum: int = Field(..., description="검은색 주사위 3개의 합 [1]")
    green_dice_symbols: List[EncounterType] = Field(..., description="초록색 주사위 2개의 기호 결과")
    has_cthulhu_symbol: bool = Field(False, description="검은 주사위에 크툴루(문어) 기호가 나왔는지 여부 [2]")

# 5. 턴 처리 결과 및 스토리 요청 (Final Payload)
class TurnOutcome(BaseModel):
    state: GameState
    target: TargetEncounter
    dice: DiceResult
    
    # 계산된 속성들
    is_success: bool = Field(False, description="조우 해결 성공 여부")
    madness_triggered: bool = Field(False, description="광기 수치 증가 여부")
    
    def calculate_outcome(self):
        """규칙에 따른 성공/실패 및 광기 판정 로직"""
        # 일요일 보스전인 경우 주간 성공 횟수만큼 난이도 차감 [3]
        effective_difficulty = self.target.base_difficulty
        if self.target.is_sunday_boss:
            effective_difficulty -= self.state.weekly_success_count
            
        # 성공 조건: 숫자 합계 >= 난이도 AND 기호 일치 [1]
        symbol_match = self.target.required_symbol in self.dice.green_dice_symbols
        number_match = self.dice.black_dice_sum >= effective_difficulty
        
        self.is_success = symbol_match and number_match
        
        # 광기 조건: 크툴루 기호 등장 시 (성공 여부 무관) [2]
        self.madness_triggered = self.dice.has_cthulhu_symbol
        if self.madness_triggered:
            self.state.madness_level += 1

    def generate_prompt(self) -> str:
        """AI에게 보낼 최종 프롬프트 생성"""
        outcome_str = "성공" if self.is_success else "실패"
        madness_str = "광기 발작이 일어났습니다!" if self.madness_triggered else "이성을 유지했습니다."
        
        return f"""
        [역할] 당신은 1926년 아캄을 배경으로 한 느와르 호러 소설의 내레이터입니다.
        
        [현재 상황]
        - 날짜: {self.state.current_date}
        - 주인공: 사설탐정 존 밀러
        - 행동: {self.target.visual_description}을(를) 상대로 {self.target.required_symbol} 시도.
        
        [결과 데이터]
        - 주사위 합계: {self.dice.black_dice_sum} (목표: {self.target.base_difficulty})
        - 결과: {outcome_str}
        - 정신 상태: {madness_str} (현재 광기 레벨: {self.state.madness_level})
        
        [요청]
        위 데이터를 바탕으로 존 밀러의 1인칭 시점 일기 혹은 독백을 작성해 주세요. 
        실패했다면 도망치거나 다치는 묘사를, 성공했다면 단서를 찾거나 적을 제압하는 묘사를 포함하세요.
        광기가 발동했다면 환각이나 심리적 공포를 묘사에 섞어주세요.
        """
```

📋 모델 설명 및 활용 포인트
이 코드는 제공해주신 자료의 핵심 규칙을 데이터 구조로 변환한 것입니다.
1. GameState (게임 상태 추적)
    ◦ weekly_success_count: 일요일 특별 조우의 난이도를 낮추는 핵심 변수이므로 반드시 추적해야 합니다.
    ◦ active_legacy_rules: 달력이 넘어갈 때마다 추가되는 새로운 규칙(예: "이제부터 은 열쇠를 사용할 수 있다")을 저장하여 AI가 스토리에 반영할 수 있게 합니다.
2. TargetEncounter (플레이어의 선택)
    ◦ visual_description: AI가 맹목적으로 결과만 출력하지 않고, "검은 고양이가 털을 곤두세웠다"와 같이 구체적인 묘사를 하기 위해 꼭 필요한 필드입니다.
    ◦ is_sunday_boss: 일요일 칸은 규칙이 다르므로 별도 플래그로 관리합니다.
3. TurnOutcome (로직 처리기)
    ◦ 이 모델 내부의 calculate_outcome 메서드는 게임의 판정 규칙을 담당합니다.
    ◦ 일요일 조우 시 난이도가 감소하는 로직(base - weekly_success)을 여기서 처리하여, AI에게는 "지난주의 노력 덕분에 쉽게 해결했다" 혹은 **"준비가 부족해 고전했다"**는 내러티브 근거를 제공합니다.
    ◦ **광기(Madness)**는 성공/실패와 별개로 작동하므로(dice.has_cthulhu_symbol), 성공했더라도 광기에 휩싸이는 복합적인 스토리 생성이 가능합니다.
이 데이터 구조를 앱의 백엔드나 로직에 적용하면, 매일 플레이어의 주사위 결과에 따라 일관성 있고 규칙에 기반한 스토리를 생성할 수 있습니다.


---

## 요청사항

매일의 스토리를 위해서, 어떤정보들이 필요한지 pydantic 형식으로 구성해서 알려줘

---

## 답변


제공된 자료와 게임의 규칙(일일 조우, 주사위 판정, 일요일 특별 규칙, 광기 시스템)을 바탕으로, AI가 매일의 스토리를 생성하는 데 필요한 데이터 구조를 Pydantic 모델로 구성해 드립니다.
이 코드는 단순한 데이터 저장이 아니라, '게임의 규칙적 결과'를 '내러티브(이야기)'로 변환하기 위한 논리적 구조입니다.
🐍 Pydantic 데이터 모델 설계

```python
    from enum import Enum
    from pydantic import BaseModel, Field, computed_field
    from typing import List, Optional
    from datetime import date

    # 1. 행동 유형 (주사위 기호) 정의 [소스 5]
    class ActionType(str, Enum):
        COMBAT = "권총 (Pistol)"           # 전투: 괴물, 광신도와의 싸움
        INVESTIGATION = "돋보기 (Lupe)"    # 조사: 문서 해독, 단서 찾기
        SEARCH = "손전등 (Flashlight)"     # 수색: 어두운 장소, 추격

    # 2. 게임의 현재 상태 (Context) - 앱이 기억해야 할 정보
    class GameState(BaseModel):
        current_date: date = Field(..., description="현재 게임 날짜 (예: 1926-01-02)")
        
        # [소스 9] 일요일 난이도 감소를 위해 필수
        weekly_success_count: int = Field(0, ge=0, description="이번 주(월~토) 성공한 조우 횟수")
        
        # [소스 12] 광기 누적 수치 (월초 0 초기화)
        madness_level: int = Field(0, ge=0, description="현재 채워진 광기 칸 개수")
        
        # [소스 13] 월간 업데이트로 추가되는 규칙/아이템
        acquired_artifacts: List[str] = Field(default=[], description="획득한 유물이나 활성화된 추가 규칙")

    # 3. 플레이어의 선택 (Target) - 달력의 특정 칸 정보
    class EncounterTarget(BaseModel):
        target_date: date = Field(..., description="선택한 칸의 날짜 (반드시 오늘 날짜일 필요는 없음 [소스 3])")
        visual_description: str = Field(..., description="칸에 그려진 그림 묘사 (예: 검은 고양이, 박쥐, 의문의 노파)")
        required_symbol: ActionType = Field(..., description="해결에 필요한 행동 유형")
        base_difficulty: int = Field(..., ge=5, le=20, description="칸에 적힌 기본 숫자 (난이도)")
        is_sunday_boss: bool = Field(False, description="일요일 특별 조우 여부 [소스 9]")

    # 4. 주사위 결과 (Input) - 플레이어의 굴림 결과
    class DiceRoll(BaseModel):
        black_dice_sum: int = Field(..., description="검은색 숫자 주사위 3개의 합 [소스 5]")
        green_dice_symbols: List[ActionType] = Field(..., description="초록색 기호 주사위 2개의 결과")
        
        # [소스 12] 성공 여부와 관계없이 광기 판정
        has_cthulhu_symbol: bool = Field(False, description="검은 주사위에 크툴루(문어) 기호가 나왔는가?")

    # 5. 최종 스토리 생성 요청 데이터 (Payload)
    class DailyStoryContext(BaseModel):
        state: GameState
        target: EncounterTarget
        roll: DiceRoll

        @computed_field
        def is_success(self) -> bool:
            """규칙에 따른 성공 여부 자동 판정"""
            # [소스 9] 일요일은 주간 성공 횟수만큼 난이도 차감
            effective_difficulty = self.target.base_difficulty
            if self.target.is_sunday_boss:
                effective_difficulty -= self.state.weekly_success_count
                effective_difficulty = max(0, effective_difficulty) # 음수 방지

            # [소스 5] 성공 조건: 합계 >= 난이도 AND 기호 일치
            number_success = self.roll.black_dice_sum >= effective_difficulty
            symbol_success = self.target.required_symbol in self.roll.green_dice_symbols
            
            return number_success and symbol_success

        @computed_field
        def madness_triggered(self) -> bool:
            """광기 발동 여부 [소스 12]"""
            return self.roll.has_cthulhu_symbol

        def get_narrative_prompt(self) -> str:
            """AI에게 전달할 최종 프롬프트 생성"""
            story_tone = "음울하고 긴장감 넘치는 러브크래프트 스타일"
            if self.state.madness_level >= 5:
                story_tone += ", 환각이 보이고 문장이 두서없는 광기 어린 스타일"

            result_desc = "성공" if self.is_success else "실패"
            
            # 일요일 보스전인 경우 추가 맥락 제공
            sunday_context = ""
            if self.target.is_sunday_boss:
                sunday_context = f"(지난주에 모은 {self.state.weekly_success_count}개의 단서가 도움이 되었습니다.)"

            return f"""
            당신은 1926년 아캄의 탐정 '존 밀러'입니다. 아래 정보를 바탕으로 오늘의 일기를 작성하세요.
            
            [상황 설정]
            - 날짜: {self.state.current_date}
            - 대상: {self.target.visual_description} ({self.target.target_date}의 칸)
            - 행동: {self.target.required_symbol.value} 시도
            
            [결과 데이터]
            - 판정: {result_desc} {sunday_context}
            - 광기 발작: {"발생함 (공포에 질림)" if self.madness_triggered else "없음"}
            - 현재 광기 수치: {self.state.madness_level} (높을수록 심리적 불안 묘사)
            
            [요청 사항]
            - 톤: {story_tone}
            - 내용: {self.target.visual_description}을(를) 상대로 행동을 취한 구체적 묘사를 포함할 것.
            - 성공 시: 단서를 찾거나 적을 물리침.
            - 실패 시: 도망치거나, 조사가 막히거나, 부상을 입음.
            """
```

📋 각 필드가 필요한 이유 (소스 기반 근거)
1. weekly_success_count (주간 성공 횟수)
    ◦ 이유: 자료 **,**에 따르면 일요일 특별 조우(Sonderbegegnung)의 난이도는 **'이번 주에 성공한 횟수'**만큼 낮아집니다.
    ◦ 스토리 반영: AI는 이 수치를 보고 "지난 며칠간 모은 단서들 덕분에 괴물의 약점을 쉽게 파악했다"라는 식으로 개연성 있는 스토리를 쓸 수 있습니다.
2. visual_description (시각적 묘사)
    ◦ 이유: 자료 ****의 이미지들을 보면 칸마다 '박쥐', '검은 고양이', '총 든 노파' 등 다양한 그림이 있습니다. 규칙상으로는 숫자와 기호만 중요하지만, 스토리상으로는 '무엇'과 싸웠는지가 가장 중요합니다.
3. has_cthulhu_symbol (광기 트리거)
    ◦ 이유: 자료 **,**에 따르면 검은 주사위에 '크툴루 기호'가 나오면 조우 성공 여부와 상관없이 광기 수치가 오릅니다.
    ◦ 스토리 반영: "임무는 성공했지만, 놈의 눈을 본 순간 형용할 수 없는 공포가 밀려왔다"와 같이 성공과 광기가 공존하는 복합적인 상황을 묘사하기 위해 필수적입니다.
4. ActionType (행동 유형)
    ◦ 이유: 자료 ****에서 기호(권총, 돋보기, 손전등)가 각각 전투, 조사, 수색을 의미한다고 명시합니다. AI가 존 밀러의 행동(총을 쏘는지, 책을 읽는지)을 결정하는 기준이 됩니다.
이 데이터 모델을 사용하면 사용자가 주사위 값만 입력해도, AI가 규칙(일요일 보너스 계산, 광기 판정 등)을 완벽히 이해하고 그에 맞는 1926년 아캄의 이야기를 창작해 줄 수 있습니다.

---

## 요청사항

이전 날짜들의 결과 및 내용들은 어떻게 관리해야 앱에서 제공하는 이야기 흐름이 매끄럽게 이어질 수 있을까?

---

앱이 1년 365일 동안 매끄러운 이야기 흐름을 유지하려면, 모든 과거의 일기를 AI에게 다 입력할 필요는 없습니다. 그렇게 하면 비용이 많이 들고 AI가 혼란스러워할 수 있습니다.
대신, 게임의 규칙(주간 단위 조사, 월간 초기화, 연간 레거시 누적)에 맞춰 **'기억해야 할 정보'를 3단계(단기/중기/장기)**로 나누어 관리하는 것이 가장 효율적입니다.
이를 구현하기 위한 관리 전략과 Pydantic 데이터 구조를 제안해 드립니다.

--------------------------------------------------------------------------------
1. 스토리 관리 전략: 3단계 기억 시스템
🛑 1단계: 단기 기억 (Weekly Context) - "수사 보드"
• 목적: 이번 주의 행동이 일요일 결전(Boss)과 연결되게 하기 위함입니다.
• 관리 대상: 이번 주 월~토 사이에 성공한 사건들의 '핵심 키워드' 요약.
• 이유: 자료에 따르면 일요일 조우는 이번 주에 성공한 횟수만큼 난이도가 낮아집니다. 스토리상으로는 "화요일에 찾은 열쇠와 목요일에 심문한 광신도의 정보 덕분에 일요일의 괴물을 쉽게 처리했다"는 식의 인과관계를 만들어야 합니다.
• 초기화: 매주 월요일에 비워집니다.
🌙 2단계: 중기 기억 (Monthly Atmosphere) - "광기의 기록"
• 목적: 한 달 동안 점차 고조되는 공포 분위기 조성.
• 관리 대상: 현재 광기(Wahnsinn) 수치 및 이번 달의 테마.
• 이유: 광기 수치는 매월 초에 0으로 초기화되지만, 월말이 다가올수록 광기가 쌓이면 AI의 문체가 더 어둡고 불안정하게 변해야 합니다.
🏛️ 3단계: 장기 기억 (Legacy & Campaign) - "존 밀러의 인벤토리"
• 목적: 1년 동안 지속되는 캐릭터의 성장과 변화 반영.
• 관리 대상: 획득한 유물(Artifact), 해금된 새로운 규칙, 지난달 뒷면 스토리의 핵심 내용.
• 이유: 자료에 따르면 달력이 넘어갈 때마다 새로운 규칙이나 아이템이 추가되며 이는 연말까지 유지됩니다. 1월에 얻은 아이템을 7월의 전투 묘사에 활용할 수 있어야 합니다.

--------------------------------------------------------------------------------
2. 구현을 위한 Pydantic 구조 (History Management)
이전 코드에 NarrativeMemory 모델을 추가하여 AI에게 "지난 이야기 요약"을 전달할 수 있도록 구성합니다.

```py
from pydantic import BaseModel, Field
from typing import List, Optional

# 1. 개별 조우의 요약 정보 (주간 기억용)
class EncounterSummary(BaseModel):
    date: str
    target_name: str # 예: "검은 고양이", "항구의 깡패"
    outcome: str     # 예: "성공(단서획득)", "실패(도망침)"
    key_narrative: str # AI가 생성한 1문장 요약 (예: "고양이 목걸이에서 기이한 문양을 발견함")

# 2. 전체 기억 관리 모델
class NarrativeMemory(BaseModel):
    # [단기 기억] 이번 주 수사 일지 (일요일이 지나면 초기화)
    weekly_log: List[EncounterSummary] = Field(default=[], description="이번 주에 발생한 사건들의 요약 리스트")
    
    # [중기 기억] 직전 일기의 마지막 문장 (연속성을 위해 필요)
    last_entry_snippet: Optional[str] = Field(None, description="어제 일기의 마지막 문장 (문맥 연결용)")
    
    # [장기 기억] 레거시 요소 (연말까지 유지) [소스 13]
    active_artifacts: List[str] = Field(default=[], description="현재 소지 중인 유물 목록 (예: '은 열쇠', '고대의 주문서')")
    major_events: List[str] = Field(default=[], description="과거에 처치한 주요 보스나 대사건 기록")

    def get_context_prompt(self) -> str:
        """AI에게 전달할 '이전 줄거리' 프롬프트 생성"""
        
        # 주간 요약글 생성
        weekly_summary = "이번 주 수사 기록:\n"
        if not self.weekly_log:
            weekly_summary += "- (아직 특별한 단서 없음)\n"
        else:
            for log in self.weekly_log:
                weekly_summary += f"- {log.date}: {log.target_name} 상대로 {log.outcome}. ({log.key_narrative})\n"

        # 장기 기억 (유물)
        inventory = ", ".join(self.active_artifacts) if self.active_artifacts else "없음"

        return f"""
        [기억해야 할 배경 정보]
        1. 현재 소지품(유물): {inventory}
        2. {weekly_summary}
        3. 직전 상황: "{self.last_entry_snippet or '새로운 하루가 시작되었다.'}"
        
        (위 정보를 바탕으로, 오늘의 사건이 과거의 발견들과 자연스럽게 연결되도록 서술하시오.)
        """
```

3. 실제 앱 적용 시나리오 (예시)
사용자가 **일요일(특별 조우)**을 플레이할 때, 앱은 위에서 정의한 get_context_prompt()를 통해 다음과 같은 정보를 AI에게 던져줍니다.
AI에게 전달되는 프롬프트 예시:
"오늘은 1월 4일 일요일이고, 존 밀러는 **항구의 밀수업자(Boss)**와 전투(권총)를 벌여 성공했습니다.
[기억해야 할 배경 정보]
1. 이번 주 수사 기록:
    ◦ 1월 1일(목): 노파를 조사하여 '오래된 주문서' 단서를 얻음.
    ◦ 1월 2일(금): 검은 고양이를 쫓아내고 '비밀 통로'의 위치를 파악함.
위 기록을 참고하여, '목요일에 얻은 주문서 지식과 금요일에 알아낸 통로를 이용해 밀수업자를 기습하여 제압하는' 일요일의 결전 스토리를 작성해 주세요."

4. 요약
앱에서 매끄러운 스토리텔링을 제공하려면 모든 텍스트를 저장하는 것이 아니라,
1. **일요일 난이도 감소 규칙**을 스토리 개연성으로 승화시키기 위해 **'이번 주 성공 요약'**을 저장하고,
2. **월간 업데이트**로 추가되는 유물/규칙을 **'장기 기억'**으로 관리하며,
3. 매일의 결과가 나오면 AI에게 '핵심 내용 1문장 요약'을 요청하여 이를 DB에 저장해두는 방식이 가장 효과적입니다.
매월 에피소드가 끝나게 해주고, 정리된 이야기를 장기기억으로 놔두고 싶어.

게임의 규칙상 매월 말은 점수를 계산하고 광기를 초기화하며, 달력 뒷면의 새로운 스토리를 확인하는 **'시즌 피날레'**와 같은 시점입니다.
따라서 앱에서도 한 달을 하나의 **'에피소드(Chapter)'**로 취급하여 마무리를 짓고, 핵심 내용만 요약해 **장기 기억(Long-term Memory)**으로 넘기는 구조가 가장 효율적입니다. 이를 구현하기 위한 프로세스와 Pydantic 모델을 제안해 드립니다.
1. 월간 에피소드 처리 프로세스
1. 점수 계산 (Scoring): 성공한 일요일 조우 개수(+5점)와 광기 게이지 만료 여부(-5점)를 합산합니다.
2. 에필로그 생성 (Narrative): AI가 지난 한 달간의 수사 기록을 바탕으로 '월간 회고록'을 작성합니다.
3. 신규 데이터 주입 (Legacy Update): 플레이어가 달력 뒷면(다음 달 예고)에 적힌 새로운 스토리와 규칙을 입력합니다.
4. 압축 및 저장 (Compress & Store): 월간 회고록을 요약하여 장기 기억 리스트에 저장하고, 데일리/위클리 로그는 초기화합니다.

--------------------------------------------------------------------------------
2. Pydantic 데이터 모델 설계
이전의 기억 모델을 확장하여 **MonthlyChapter**와 **GlobalCampaignMemory**를 정의합니다.
```py
from pydantic import BaseModel, Field
from typing import List, Optional

# 1. 월간 에피소드 결산 데이터 (한 달이 끝날 때 생성)
class MonthlyChapterSummary(BaseModel):
    month_name: str  # 예: "1926년 1월"
    final_score: int # [소스 12] 계산된 월간 점수
    
    # 내러티브 요약
    bosses_defeated: List[str] # 처치한 일요일 보스 목록
    madness_state: str         # 월말 시점 존 밀러의 정신 상태 (예: "피폐해짐", "냉철함")
    chapter_summary: str       # AI가 생성한 3~4줄 분량의 '지난 이야기' 요약
    
    # [소스 13] 달력 뒷면에서 얻은 새로운 레거시 정보
    new_rules_unlocked: List[str] # 예: ["은 열쇠 사용 가능", "주문서 해독 보너스"]
    story_revelation: str         # 달력 뒷면의 스토리 텍스트 (다음 달 분위기 조성용)

# 2. 전체 캠페인(1년)을 관장하는 장기 기억 저장소
class GlobalCampaignMemory(BaseModel):
    # 완료된 챕터들의 아카이브 (장기 기억)
    past_chapters: List[MonthlyChapterSummary] = Field(default=[], description="지나간 달들의 요약 기록")
    
    # 현재 적용 중인 모든 활성 규칙 (누적됨)
    active_artifacts: List[str] = Field(default=[], description="현재 사용 가능한 모든 유물 및 특수 규칙")
    
    def get_new_month_prompt(self, current_month: str) -> str:
        """새로운 달(1일)이 시작될 때 AI에게 줄 프롬프트 생성"""
        
        # 가장 최근 챕터(직전 달) 정보 가져오기
        last_chapter = self.past_chapters[-1] if self.past_chapters else None
        
        legacy_rules = ", ".join(self.active_artifacts)
        
        prompt = f"""
        [시스템] {current_month}의 새로운 에피소드가 시작됩니다.
        
        [지난 이야기 요약]
        {last_chapter.chapter_summary if last_chapter else "모험의 시작입니다."}
        
        [현재 존 밀러의 상태]
        - 정신 상태: 지난달의 광기는 초기화되었으나, 기억은 남아있습니다. ({last_chapter.madness_state if last_chapter else '정상'})
        - 보유 능력/유물: {legacy_rules}
        
        [새로운 국면 (New Story)]
        {last_chapter.story_revelation if last_chapter else "아캄의 거리에는 기묘한 안개가 깔려 있습니다."}
        
        위 정보를 바탕으로 {current_month} 1일의 오프닝 일기를 작성해 주세요. 
        지난달의 사건을 회상하되, 새로운 위협에 대비하는 비장한 톤으로 시작하세요.
        """
        return prompt

    def close_month(self, chapter_data: MonthlyChapterSummary):
        """월말 정산 처리: 아카이브에 저장하고, 새 규칙을 활성 목록에 추가"""
        self.past_chapters.append(chapter_data)
        
        # [소스 13] 새로운 규칙/유물은 연말까지 계속 유지되므로 누적 리스트에 추가
        self.active_artifacts.extend(chapter_data.new_rules_unlocked)
```

--------------------------------------------------------------------------------
3. 실제 작동 예시 (1월 종료 -> 2월 시작)
상황: 사용자가 1월 31일 게임을 마치고, 달력 페이지를 넘긴 후 앱에서 "2월 시작하기"를 눌렀습니다.
Step A. 앱이 사용자에게 요청하는 입력 (Input)
• "1월에 성공한 일요일 조우는 몇 개였나요?" (점수 계산용) -> 3개
• "광기(문어) 칸이 꽉 찼나요?" -> 아니오
• "달력 1월 뒷면에 적힌 '새로운 규칙'이 있나요?" -> [텍스트 입력: "이제부터 고대 문양(Elder Sign)을 사용하여 주사위를 다시 굴릴 수 있다."]
• "뒷면의 스토리는 무엇인가요?" -> [텍스트 입력: "아캄의 하수구에서 이상한 점액질이 발견되었다..."]
Step B. AI의 처리 (Internal Processing)
AI는 1월의 위클리 로그들을 모아 요약하고, 점수를 계산하여 MonthlyChapterSummary를 생성합니다.
```json
{
  "month_name": "1월",
  "final_score": 15,
  "madness_state": "약간의 신경쇠약",
  "chapter_summary": "존 밀러는 아캄 박물관의 도난 사건을 해결하고 항구의 밀수업자를 제압했다. 하지만 수사 과정에서 고대의 존재에 대한 끔찍한 진실을 일부 목격했다.",
  "new_rules_unlocked": ["고대 문양(재굴림) 사용 가능"],
  "story_revelation": "하수구에서 발견된 점액질은 단순한 오물이 아니다."
}
```
Step C. 2월 1일 스토리 생성 (Output)
get_new_month_prompt 메서드를 통해 생성된 프롬프트로 2월의 첫 일기가 작성됩니다.

존 밀러의 일기 (1926년 2월 1일)
"1월의 악몽은 끝났다고 생각했다. 박물관과 항구에서의 사투 끝에 나는 잠시나마 휴식을 취할 수 있었다. 내 정신을 갉아먹던 광기의 속삭임도 지금은 잦아들었다.
하지만 달력을 넘기자마자 새로운 불길함이 엄습한다. 하수구에서 발견된 그 역겨운 점액질... 그것이 의미하는 바를 나는 알고 있다. 다행히 지난 수사에서 얻은 지식으로 **'고대 문양'**을 활용하는 법을 익혔다. 이것이 다가올 위협으로부터 나를 지켜주기를.
2월의 차가운 바람이 분다. 다시 사냥을 나갈 시간이다."

4. 요약
이 구조를 사용하면:
1. 매월 깔끔한 마무리: 점수와 광기 초기화를 확실하게 처리합니다.
2. 데이터 효율성: 매일의 자잘한 주사위 결과는 버리고, **'요약된 스토리'**와 **'해금된 규칙(Legacy)'**만 남겨서 토큰 비용을 절약합니다.
3. 게임의 진화 반영: 자료에 언급된 '달력이 넘어갈수록 추가되는 규칙'을 active_artifacts 리스트에 계속 쌓아감으로써, 12월에는 매우 강력하고 노련한 탐정의 모습을 묘사할 수 있습니다.

---

## 요청사항

데이터 저장용 json을 만들고 싶은데 구조는 어떻게 해야할까?

---

## 답변

앱 개발을 위한 데이터 저장용 JSON 구조를 제안해 드립니다. 이 구조는 앞서 논의한 단기(주간), 중기(월간), 장기(연간 레거시) 기억 시스템과 게임의 핵심 규칙을 모두 반영하도록 설계되었습니다.
크게 current_state (현재 게임 상태), campaign_history (지나간 기록), legacy_inventory (누적된 규칙/아이템) 세 부분으로 나뉩니다.

```json
{
  "save_file_info": {
    "player_name": "John Miller",
    "campaign_year": 1926,
    "last_played": "2025-12-31T23:59:00"
  },

  "current_state": {
    "description": "게임 플레이 중 실시간으로 변동되는 데이터입니다.",
    "today_date": "1926-01-04",
    
    "madness_tracker": {
      "current_level": 1,
      "description": "이번 달에 누적된 광기 수치 (매월 초 0으로 초기화됨) [1]"
    },
    
    "weekly_progress": {
      "current_week_number": 1,
      "success_count": 3,
      "description": "일요일 특별 조우 난이도 차감을 위해 이번 주(월~토) 성공 횟수를 추적 [2]",
      "completed_days_in_week": ["1926-01-01", "1926-01-02", "1926-01-03"]
    }
  },

  "legacy_inventory": {
    "description": "달력이 넘어갈 때마다 추가되어 연말까지 유지되는 요소들 [3]",
    "active_rules": [
      {
        "id": "rule_feb_01",
        "name": "고대 표식(Elder Sign)",
        "effect_text": "주사위 1개를 다시 굴릴 수 있음",
        "unlocked_month": "February"
      }
    ],
    "collected_artifacts": [
      "은 열쇠",
      "미스카토닉 대학 출입증"
    ]
  },

  "campaign_history": {
    "description": "지나간 에피소드들의 요약 및 상세 기록",
    "monthly_chapters": [
      {
        "month": "January",
        "is_completed": true,
        "monthly_score": 10,
        "description": "일요일 조우 성공(+5점) - 광기 만료(-5점) 계산 결과 [1]",
        
        "chapter_summary": "존 밀러는 1월의 눈보라 속에서 항구의 밀수업자 조직을 소탕했다. 하지만 그 과정에서 심연의 공포를 목격하고 말았다. (AI가 생성한 월간 요약)",
        
        "daily_logs": [
          {
            "date": "1926-01-01",
            "day_of_week": "Thursday",
            "target_encounter": {
              "visual_desc": "총을 든 노파",
              "action_type": "COMBAT", 
              "base_difficulty": 8,
              "description": "권총(전투) 기호가 필요한 조우 [4]"
            },
            "outcome": {
              "is_success": true,
              "madness_triggered": false,
              "description": "성공 조건(숫자합+기호) 달성 및 크툴루 기호 등장 여부 [1, 4]"
            },
            "narrative_text": "노파는 겉모습과 달리 민첩했다. 하지만 나는 침착하게..."
          },
          {
            "date": "1926-01-04",
            "day_of_week": "Sunday",
            "target_encounter": {
              "visual_desc": "석궁을 든 사냥꾼",
              "action_type": "INVESTIGATION",
              "base_difficulty": 13,
              "is_sunday_boss": true
            },
            "outcome": {
              "is_success": true,
              "madness_triggered": true,
              "applied_bonus": 3,
              "description": "주간 성공 횟수 3회만큼 난이도 차감 적용됨 (13 -> 10) [2]"
            },
            "narrative_text": "지난 며칠간 모은 단서 덕분에 놈의 은신처를 쉽게 찾았다. 하지만 놈의 눈을 본 순간..."
          }
        ]
      }
    ]
  }
}
```


📂 구조 설계의 핵심 근거
1. weekly_progress.success_count:
    ◦ 이 필드는 가장 중요합니다. 규칙서에 따르면 일요일(특별 조우)의 난이도는 **'이번 주에 성공한 횟수'**만큼 감소하기 때문입니다. 앱은 매주 월요일 이 숫자를 0으로 초기화하고, 평일 성공 시마다 +1을 해줘야 합니다.
2. madness_tracker.current_level:
    ◦ 광기(Wahnsinn)는 조우의 성공 여부와 관계없이 검은 주사위에 크툴루 기호가 나오면 즉시 상승합니다. 또한 매월 초에 0으로 초기화되므로, current_state에서 관리하다가 월말 정산 후 0으로 리셋해야 합니다.
3. legacy_inventory:
    ◦ 자료에 따르면 달력이 넘어갈 때마다 이전 달 뒷면에 있는 **'새로운 규칙'**과 **'마법 유물'**이 공개되며, 이는 연말까지 유효합니다. 따라서 월별 데이터와 분리하여 전역(Global) 변수로 관리해야 합니다.
4. daily_logs 내부의 outcome:
    ◦ 성공(is_success)과 광기 발동(madness_triggered)을 분리했습니다. 성공했지만 광기가 발동하는 경우(예: 괴물은 잡았지만 정신적 충격을 받음)를 묘사하기 위함입니다.

이 JSON 구조를 사용하면, 앱을 껐다 켜도 "현재 광기 수치"나 "이번 주 일요일 보스전 보너스"를 잃어버리지 않고 게임을 이어서 진행할 수 있습니다.

---

## 요청사항

한번 생성된 ai출력데이터는 원본을 그대로 가지고 있어야 나중에 다시 조회할 때 그 내용 그대로 보여줄수 있잖아. 그런 부분까지 개발에 반영되려면 어떤 json을 추가할까?

---

## 답변

AI가 한 번 생성한 텍스트를 나중에 다시 조회할 때 똑같이 보여주려면, 단순히 결과 값만 저장하는 것이 아니라 **생성된 텍스트 그 자체(Raw Text)**를 '불변의 상태'로 저장하는 구조가 필요합니다. 이를 '캐싱(Caching)' 또는 **'아카이빙(Archiving)'**이라고 합니다.
개발 관점에서 "나중에 다시 읽어볼 일기장" 기능을 완벽하게 구현하기 위해 필요한 JSON 구조(frozen_narrative)를 추가하여 제안해 드립니다.
📚 스토리 보존을 위한 확장 JSON 구조
기존의 campaign_history 내의 daily_logs 부분에 **ai_generated_content**라는 객체를 추가합니다. 이 부분은 한 번 작성되면 수정되지 않는 '박제된 데이터'입니다.
```json
{
  "campaign_history": {
    "monthly_chapters": [
      {
        "month": "January",
        "daily_entries": [
          {
            "date": "1926-01-01",
            "is_finalized": true, // 이 플래그가 true면 더 이상 AI를 호출하지 않고 저장된 텍스트만 보여줌
            
            // 1. 게임 로직 데이터 (통계 및 규칙 처리용)
            "game_logic_snapshot": {
              "target_name": "총을 든 노파",
              "action_type": "COMBAT",
              "dice_result": { "sum": 13, "symbols": ["PISTOL", "FLASHLIGHT"] },
              "is_success": true,
              "madness_triggered": false
            },

            // 2. [핵심] AI 출력 데이터 아카이빙 (조회용 불변 데이터)
            "ai_generated_content": {
              "content_id": "uuid-1234-5678", // 고유 ID
              "generated_at": "2025-01-01T10:30:00Z", // 생성 시각
              
              // (A) 사용자에게 보여줄 최종 텍스트 (줄바꿈 포함 원본)
              "main_text": "노파의 주름진 손이 품 안으로 들어가는 순간, 존 밀러의 본능이 경고음을 울렸다. '탕!'...",
              
              // (B) 텍스트의 분위기/태그 (UI 연출용)
              "tone_tag": "Suspense", // 예: 화면 배경음악이나 색상 테마 결정에 사용
              
              // (C) AI가 생성한 '한 줄 요약' (달력 목록 보기용)
              "summary_line": "노파를 제압하고 품 안에서 기이한 문양의 메달을 발견함.",
              
              // (D) 디버깅 및 재생성용 프롬프트 백업 (선택 사항)
              "prompt_snapshot": "당신은 1926년 아캄의 탐정... (중략) ... 결과를 바탕으로 일기를 작성해."
            }
          }
        ]
      }
    ]
  }
}
```

--------------------------------------------------------------------------------

💡 왜 이런 필드들이 추가되어야 할까요?
1. is_finalized (작성 완료 플래그)
• 기능: 사용자가 해당 날짜를 클릭했을 때, 이 값이 true이면 AI API를 호출하지 않고 로컬에 저장된 main_text를 즉시 불러옵니다.
• 이유: API 비용을 절약하고, 로딩 없이 즉각적으로 과거의 일기를 보여주기 위함입니다. 또한, 매번 내용이 바뀌면 플레이어가 몰입하기 어렵습니다.
2. main_text (본문 저장)
• 기능: AI가 내뱉은 텍스트 전체를 문자열로 저장합니다.
• 활용: 앱 내의 '지난 일기장 다시보기' 메뉴에서 이 텍스트를 그대로 출력합니다. 사용자가 이 내용을 읽으며 지난 사건을 회상하고, 12월 31일 게임이 끝난 후 전체 스토리를 정주행할 수 있게 해줍니다.
3. summary_line (목록용 요약)
• 기능: 긴 본문 대신 달력의 날짜 칸에 작게 표시할 1줄 요약입니다.
• 활용: 달력 화면(캘린더 뷰)에서 날짜를 누르지 않아도 "아, 1월 3일에는 박쥐한테 당했었지"라고 직관적으로 알 수 있게 합니다. (게임 규칙상 책을 색칠하는 행위를 디지털 텍스트로 대체)
4. game_logic_snapshot (당시 상황 스냅샷)
• 기능: 텍스트와 별개로, 그 당시의 주사위 결과와 성공 여부를 따로 저장합니다.
• 이유: 나중에 앱이 업데이트되어 규칙이 바뀌더라도, **"그 당시에는 성공으로 판정받았다"**는 사실을 보존하기 위함입니다. 텍스트(main_text)와 논리(game_logic)를 분리해서 저장해야 데이터 무결성이 유지됩니다.
📱 개발 시나리오: '회상하기' 기능 구현
이 JSON 구조를 사용하면 다음과 같은 기능을 구현할 수 있습니다.
1. 일기장 모드: 사용자가 "1월 기록 보기" 버튼을 누릅니다.
2. 데이터 로드: 앱은 campaign_history -> January 배열을 순회합니다.
3. 화면 표시: ai_generated_content.main_text들을 이어 붙여서 하나의 소설책처럼 보여줍니다.
4. UI 연출: tone_tag가 "Madness"로 되어 있는 날짜의 페이지는 붉은색 필터를 씌우거나 글자가 흔들리는 효과를 줍니다.
이 구조는 단순한 저장을 넘어, **'나만의 크툴루 연대기'**를 완성해 나가는 느낌을 사용자에게 확실히 줄 수 있습니다.

---

## 요청사항

매번 ai에게 요청할 시스템프롬프트와 실제 프롬프트의 예시를 제시해줘

---

## 답변

앱 개발 시 AI API(예: GPT-4, Claude 3.5 Sonnet)에 전송할 **시스템 프롬프트(System Prompt)**와 매 턴마다 데이터가 주입된 **실제 사용자 프롬프트(User Prompt)**의 구체적인 예시를 작성해 드립니다.
이 프롬프트는 앞서 설계한 JSON 데이터 구조를 바탕으로 **게임의 규칙(성공/실패, 광기, 일요일 보너스)**을 자연스러운 느와르 호러 소설로 변환하도록 설계되었습니다.

--------------------------------------------------------------------------------
1. 시스템 프롬프트 (System Prompt)
AI에게 부여할 영구적인 역할 정의입니다. 앱이 실행될 때 한 번 설정되거나, 매 요청마다 상단에 포함됩니다.
```markdown
# Role Definition
당신은 1926년 미국 매사추세츠주 아컴(Arkham)을 배경으로 한 텍스트 어드벤처 게임의 '메인 작가'이자 '내레이터'입니다.
주인공은 사설탐정 '존 밀러(John Miller)'입니다.

# Tone & Style
1. 장르: 러브크래프트(Lovecraftian) 코즈믹 호러 + 하드보일드 느와르.
2. 문체: 1인칭 관찰자 시점(존 밀러의 일기). 건조하고 냉소적이지만, 공포 앞에서는 감정적으로 흔들리는 묘사를 사용하세요.
3. 길이: 3~5문장 내외의 간결하지만 임팩트 있는 문단.
4. 언어: 한국어(Korean)로 출력하세요.

# Core Rules for Narrative
1. 입력된 [결과 데이터]를 반드시 스토리에 반영해야 합니다.
   - 성공: 존 밀러가 기지를 발휘하거나 무력을 사용해 상황을 해결함.
   - 실패: 존 밀러가 도망치거나, 단서를 놓치거나, 부상을 입음.
   - 광기(Madness) 발동: 결과의 성공/실패 여부와 관계없이, 기괴한 환청, 환각, 심리적 압박감을 묘사해야 함.
2. [일요일 특별 조우]인 경우:
   - "주간 성공 횟수"가 높다면, 지난주의 조사가 결정적인 도움이 되었음을 언급하세요.
3. [유물/아이템]이 있다면:
   - 상황 묘사 시 해당 아이템을 활용하는 장면을 은유적으로 넣으세요.
```

--------------------------------------------------------------------------------
2. 실제 사용자 프롬프트 (User Prompt) - 예시
매일 플레이어가 주사위를 굴린 후, 앱이 AI에게 실제로 보내는 메시지입니다. { } 부분이 변수입니다.
시나리오 A: 평범한 조사의 성공 (1월 2일 금요일)
상황: 검은 고양이를 조사(돋보기)하여 성공함. 광기 없음.
[Context]
- 날짜: 1926년 1월 2일 금요일
- 현재 광기 수치: 0 (매우 이성적임)
- 보유 아이템: 없음

[Target Encounter]
- 대상: 도서관의 검은 고양이 (Black Cat)
- 행동 유형: 조사 (Investigation/돋보기)
- 상황: 서가 사이를 지나가는 기묘한 눈빛의 고양이

[Game Result]
- 판정: **성공 (Success)**
- 광기 발동 여부: 없음 (No Madness)

[Request]
위 정보를 바탕으로 존 밀러의 짧은 일기를 작성해 주세요.
고양이를 통해 무언가 중요한 단서를 발견하는 과정을 묘사하세요.

🤖 AI 출력 예시: "도서관의 먼지 쌓인 공기 속에서 그 검은 고양이와 눈이 마주쳤다. 녀석은 나를 유인하듯 서가 깊숙한 곳으로 이끌었다. 녀석이 멈춰 선 곳의 책을 꺼내보니, 페이지 사이에 누군가 급하게 끼워 넣은 쪽지가 있었다. 놈들의 회합 장소가 적힌 결정적인 단서였다. 짐승조차 이 도시의 비밀을 알고 있는 듯하다."

--------------------------------------------------------------------------------
시나리오 B: 일요일 보스전 성공 (1월 4일 일요일)
상황: 일요일 특별 조우. 주간 성공 횟수(3회) 덕분에 난이도가 낮아져서 성공함.
[Context]
- 날짜: 1926년 1월 4일 일요일
- 현재 광기 수치: 1 (약간의 불안)
- 지난 이야기 요약: 노파에게서 주문서를 얻었고, 검은 고양이를 통해 비밀 장소를 알아냈음.

[Target Encounter]
- 대상: 석궁을 든 사냥꾼 (Crossbow Hunter)
- 행동 유형: 전투 (Combat/권총)
- **특이 사항: 일요일 특별 조우 (Boss)**

[Game Result]
- 판정: **성공 (Success)**
- **승리 요인: 지난주에 모은 3개의 단서가 결정적이었음.**
- 광기 발동 여부: 없음

[Request]
일요일의 결전입니다. 지난주에 얻은 정보들 덕분에 적의 움직임을 미리 예측하고 제압하는 장면을 묘사하세요.
🤖 AI 출력 예시: "놈은 석궁을 겨누고 골목 끝에서 나를 기다리고 있었다. 하지만 나는 이미 금요일에 발견한 쪽지를 통해 놈의 매복 위치를 알고 있었다. 화살이 내 코트 자락을 스치고 지나가기도 전에, 나는 놈의 사각지대로 파고들어 권총을 겨눴다. '지난 3일간의 조사가 헛되지 않았군.' 놈을 제압하며 나는 안도의 한숨을 내쉬었다."

--------------------------------------------------------------------------------
시나리오 C: 실패와 광기의 발동 (상황 악화)
상황: 박쥐 떼에게 습격당해 실패했고, 주사위에서 크툴루 기호가 나와 광기 수치가 상승함.
[Context]
- 날짜: 1926년 1월 15일
- **현재 광기 수치: 4 (심각한 정신 착란 상태)**
- 보유 아이템: 은 열쇠

[Target Encounter]
- 대상: 흡혈 박쥐 떼 (Vampire Bats)
- 행동 유형: 수색 (Search/손전등)

[Game Result]
- 판정: **실패 (Failure)**
- **광기 발동 여부: 발동됨 (Triggered!)** -> 검은 주사위에 크툴루 기호 등장.

[Request]
임무에 실패하여 도망치는 상황입니다.
성공 여부와 별개로, '광기'가 발동했습니다. 박쥐들의 날개짓 소리가 악마의 속삭임처럼 들리거나, 현실이 왜곡되는 공포를 묘사하세요. 문장을 조금 더 두서없고 다급하게 작성하세요.
🤖 AI 출력 예시: "손전등 불빛이 꺼졌다. 아니, 어둠이 빛을 삼켜버린 건가? 놈들의 날개짓 소리가... 찢어지는 비명소리처럼 뇌를 파고든다. 젠장, 이건 박쥐가 아니야! 저건 고대의... 안 돼, 보지 마! 나는 바닥을 기며 도망쳤다. 은 열쇠가 주머니에서 뜨겁게 달아오르는 것 같았다. 내 머릿속에서 누군가 웃고 있다. 제발 멈춰..."

--------------------------------------------------------------------------------
3. 개발 시 팁 (Prompt Engineering)
1. 동적 변수 주입: 위 예시의 [Context], [Target Encounter], [Game Result] 섹션은 앱 코드(Python/JS)에서 JSON 데이터를 문자열로 변환하여 채워 넣어야 합니다.
2. 광기 단계별 톤 조절: 현재 광기 수치가 높을수록 AI에게 "문장을 짧게 끊어라", "환각을 묘사하라"는 추가 지침을 [Request] 부분에 조건부로 넣어주면 훨씬 몰입감이 높아집니다.
3. Legacy 반영: 보유 아이템 리스트에 있는 항목을 프롬프트에 포함시키면, AI가 "위기의 순간 주머니 속의 **성수(Holy Water)**를 꽉 쥐었다"는 식의 디테일을 살려줄 수 있습니다.